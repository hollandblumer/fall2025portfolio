<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Springy Blob Text with Real Counters</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #c5c5c5;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script>
      /* ================================
         URL PARAMS (TEXT + SCALE)
      ================================ */

      const params = new URLSearchParams(window.location.search);

      const TEXT_STRING = params.get("text") || "WORK";

      const DEFAULT_SCALE = 3.7;
      let scaleRaw = parseFloat(params.get("scale"));
      if (Number.isNaN(scaleRaw)) scaleRaw = DEFAULT_SCALE;

      // Clamp so we don't get absurd values that generate tons of points
      const SCALE_MULTIPLIER = Math.min(Math.max(scaleRaw, 2.5), 5.0);

      /* ================================
         CONFIG
      ================================ */

      let letterFont;
      const FONT_URL =
        "https://assets.codepen.io/9259849/RubikMonoOne-Regular_1.ttf";

      const vertexDistanceRel = 0.008;
      let effectiveVertexDistance;

      /* ================================
         Spring physics (your PolyWave style)
      ================================ */

      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        moveTo(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }
        delta(p) {
          return [this.x - p.x, this.y - p.y];
        }
        distance(p) {
          const dx = p.x - this.x;
          const dy = p.y - this.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
      }

      const ELASTICITY = 0.03;
      const DAMPING = 0.75;
      const MASS = 2;
      const ADJACENT_SPRING_CONSTANT = 0.1;

      let MOUSE_STRENGTH = 0.7;
      let MOUSE_RADIUS;

      // subtle automatic wobble
      const AUTO_WOBBLE_STRENGTH = 0.4;

      /** A spring point that behaves like your PolyWave springs */
      class Spring extends Point {
        constructor({
          x,
          y,
          mass = MASS,
          elasticity = ELASTICITY,
          damping = DAMPING,
        }) {
          super(x, y);
          this.ox = x;
          this.oy = y;
          this.vx = 0;
          this.vy = 0;
          this.fx = 0;
          this.fy = 0;
          this.mass = mass;
          this.elasticity = elasticity;
          this.damping = damping;
          this.attractors = [];
        }

        applyForce(x, y) {
          this.fx += x;
          this.fy += y;
        }

        addAttractor(p) {
          this.attractors.push(p);
        }

        setForceFromAttractors() {
          this.attractors.forEach((p) => {
            const fx = ADJACENT_SPRING_CONSTANT * p.vx;
            const fy = ADJACENT_SPRING_CONSTANT * p.vy;
            this.applyForce(fx, fy);
          });
        }

        applyForceFromMouse(pointer) {
          const distance = this.distance(pointer.position);
          if (distance < MOUSE_RADIUS) {
            const [dx, dy] = pointer.delta();
            const power = (1 - distance / MOUSE_RADIUS) * MOUSE_STRENGTH;
            this.applyForce(dx * power, dy * power);
          }
        }

        // small noise-based wobble so it moves without user interaction
        applyAutoWobble() {
          const t = frameCount * 0.01;
          const nx = noise(this.ox * 0.01, this.oy * 0.01, t);
          const ny = noise(this.ox * 0.01 + 100.0, this.oy * 0.01 + 100.0, t);
          const ax = (nx - 0.5) * AUTO_WOBBLE_STRENGTH;
          const ay = (ny - 0.5) * AUTO_WOBBLE_STRENGTH;
          this.applyForce(ax, ay);
        }

        setSpringForce() {
          const fx = (this.ox - this.x) * this.elasticity;
          const fy = (this.oy - this.y) * this.elasticity;
          this.fx += fx;
          this.fy += fy;
        }

        solveVelocity() {
          if (this.fx === 0 && this.fy === 0) return;
          const ax = this.fx / this.mass;
          const ay = this.fy / this.mass;
          this.vx = this.damping * this.vx + ax;
          this.vy = this.damping * this.vy + ay;
          this.x += this.vx;
          this.y += this.vy;
          this.fx = 0;
          this.fy = 0;
        }

        update(pointer) {
          this.setForceFromAttractors();
          this.applyForceFromMouse(pointer);
          this.applyAutoWobble();
          this.setSpringForce();
          this.solveVelocity();
        }
      }

      /* ================================
         Pointer
      ================================ */

      class SpringPointer {
        constructor(x, y) {
          this.position = new Point(x, y);
          this.lastPosition = new Point(x, y);
        }
        updateFromMouse(mx, my) {
          this.lastPosition.moveTo(this.position.x, this.position.y);
          this.position.moveTo(mx, my);
        }
        delta() {
          return this.position.delta(this.lastPosition);
        }
      }

      /* ================================
         Global state
      ================================ */

      let pointer;
      let springs = [];
      let blobs = [];

      /* ================================
         p5 lifecycle
      ================================ */

      function preload() {
        letterFont = loadFont(FONT_URL);
      }

      function setup() {
        createCanvas(windowWidth, windowHeight);
        colorMode(RGB, 255);
        background("#c5c5c5");
        noStroke();

        effectiveVertexDistance = vertexDistanceRel * min(width, height);
        MOUSE_RADIUS = min(width, height) * 0.18;

        pointer = new SpringPointer(width / 2, height / 2);

        buildLetters();
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        background("#c5c5c5");
        effectiveVertexDistance = vertexDistanceRel * min(width, height);
        MOUSE_RADIUS = min(width, height) * 0.18;
        buildLetters();
      }

      /* ================================
         Build per-letter blobs
      ================================ */

      function buildLetters() {
        springs = [];
        blobs = [];

        const minLength = min(width, height);
        const radius = minLength * 0.16;
        const fontSize = radius * SCALE_MULTIPLIER;

        const text = TEXT_STRING;
        const chars = text.split("");

        const charInfos = chars.map((ch) => {
          if (ch === " ")
            return { char: " ", width: radius * 0.8, isSpace: true };
          const b = letterFont.textBounds(ch, 0, 0, fontSize);
          return { char: ch, width: b.w, isSpace: false };
        });

        const LETTER_GAP = radius * 0.25;

        let totalW = 0;
        for (let i = 0; i < charInfos.length; i++) {
          totalW += charInfos[i].width;
          if (i < charInfos.length - 1) totalW += LETTER_GAP;
        }

        const targetWidth = totalW * 0.9;
        const scaleX = targetWidth / totalW;

        const lineStartX = (width - targetWidth) / 2;
        const baseY = height * 0.55;

        let xCursor = 0;
        for (let i = 0; i < charInfos.length; i++) {
          const info = charInfos[i];
          if (info.isSpace) {
            xCursor += info.width;
            if (i < charInfos.length - 1) xCursor += LETTER_GAP;
            continue;
          }

          const cx = lineStartX + (xCursor + info.width / 2) * scaleX;

          const blobLoops = generateLetterLoops(
            cx,
            baseY,
            radius,
            info.char,
            fontSize
          );
          blobs.push({ loops: blobLoops });

          blobLoops.forEach((loop) => {
            loop.forEach((s) => springs.push(s));
          });

          xCursor += info.width;
          if (i < charInfos.length - 1) xCursor += LETTER_GAP;
        }

        blobs.forEach((blob) => {
          blob.loops.forEach((loop) => {
            const len = loop.length;
            if (len < 2) return;
            for (let i = 0; i < len; i++) {
              const curr = loop[i];
              const prev = loop[(i - 1 + len) % len];
              const next = loop[(i + 1) % len];
              curr.addAttractor(prev);
              curr.addAttractor(next);
            }
          });
        });
      }

      function generateLetterLoops(offsetX, offsetY, radius, letter, fontSize) {
        const bounds = letterFont.textBounds(letter, 0, 0, fontSize);
        const bx = bounds.x;
        const by = bounds.y;
        const bw = bounds.w;
        const bh = bounds.h;

        const rawPoints = letterFont.textToPoints(letter, 0, 0, fontSize, {
          sampleFactor: 0.6,
          simplifyThreshold: 0,
        });

        const allLoops = [];
        let currentLoop = [];
        let lastRaw = null;

        const breakThreshold = effectiveVertexDistance * 8;

        for (let i = 0; i < rawPoints.length; i++) {
          const pt = rawPoints[i];

          if (lastRaw) {
            const rawD = dist(lastRaw.x, lastRaw.y, pt.x, pt.y);
            if (rawD > breakThreshold && currentLoop.length > 0) {
              allLoops.push(currentLoop);
              currentLoop = [];
            }
          }
          lastRaw = { x: pt.x, y: pt.y };

          const px = pt.x - bx - bw * 0.5 + offsetX;
          const py = pt.y - by - bh * 0.5 + offsetY;

          const PARTICLE_SPACING = effectiveVertexDistance * 1.0;

          if (currentLoop.length === 0) {
            const s = new Spring({
              x: px,
              y: py,
              elasticity: random(0.02, 0.04),
              damping: random(0.7, 0.8),
            });
            currentLoop.push(s);
          } else {
            const last = currentLoop[currentLoop.length - 1];
            const d = dist(last.x, last.y, px, py);
            if (d >= PARTICLE_SPACING) {
              const s = new Spring({
                x: px,
                y: py,
                elasticity: random(0.02, 0.04),
                damping: random(0.7, 0.8),
              });
              currentLoop.push(s);
            }
          }
        }

        if (currentLoop.length > 0) allLoops.push(currentLoop);

        const processedLoops = allLoops.filter((loop) => loop.length >= 3);
        return processedLoops;
      }

      /* ================================
         Draw
      ================================ */

      function draw() {
        background("#c5c5c5");

        pointer.updateFromMouse(mouseX, mouseY);

        noFill();
        stroke(165, 165, 165, 90);
        strokeWeight(1.5);
        circle(pointer.position.x, pointer.position.y, MOUSE_RADIUS * 0.8);

        for (let i = 0; i < springs.length; i++) {
          springs[i].update(pointer);
        }

        for (let b = 0; b < blobs.length; b++) {
          drawLetterBlob(blobs[b]);
        }
      }

      function drawLetterBlob(blob) {
        if (!blob.loops || blob.loops.length === 0) return;

        const contours = [];

        for (let li = 0; li < blob.loops.length; li++) {
          const contour = blob.loops[li];
          if (contour.length < 3) continue;

          const len = contour.length;
          let smooth = new Array(len);

          for (let i = 0; i < len; i++) {
            const p = contour[i];
            smooth[i] = { x: p.x, y: p.y };
          }

          const passes = 4;
          for (let k = 0; k < passes; k++) {
            const tmp = new Array(len);
            for (let i = 0; i < len; i++) {
              const prev = smooth[(i - 1 + len) % len];
              const curr = smooth[i];
              const next = smooth[(i + 1) % len];
              tmp[i] = {
                x: (prev.x + curr.x * 2 + next.x) / 4,
                y: (prev.y + curr.y * 2 + next.y) / 4,
              };
            }
            smooth = tmp;
          }

          const curvePts = [];
          curvePts.push(smooth[len - 2]);
          curvePts.push(smooth[len - 1]);
          for (let i = 0; i < len; i++) {
            curvePts.push(smooth[i]);
          }
          curvePts.push(smooth[0]);
          curvePts.push(smooth[1]);

          contours.push(curvePts);
        }

        if (!contours.length) return;

        const ctx = drawingContext;
        ctx.save();
        ctx.fillStyle = "#F7EAAC";
        ctx.beginPath();

        contours.forEach((curvePts) => {
          if (!curvePts.length) return;
          ctx.moveTo(curvePts[0].x, curvePts[0].y);
          for (let i = 1; i < curvePts.length; i++) {
            const pt = curvePts[i];
            ctx.lineTo(pt.x, pt.y);
          }
          ctx.closePath();
        });

        ctx.fill("evenodd");
        ctx.restore();
      }
    </script>
  </body>
</html>
